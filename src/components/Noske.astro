---
import EditionFragment from "./EditionFragment.astro";
import Register from "./Register.astro";
// import VirtualKeyboard from "./VirtualKeyboard.astro";
---

<div>
	<div class="flex flex-row">
		<Register />
		<div class="sticky top-24 flex w-[100%] flex-col">
			<div class="w-[100%] p-4 text-left">
				<div
					class="xs:max-w-[200px] mx-auto max-w-[1000px] sm:max-w-[300px] md:max-w-[600px] lg:max-w-[800px]"
				>
					<h4 class="pl-2 pt-2 text-left font-segoe text-xl">
						<img class="inline" src="/Suche.jpg" alt="Suchet" title="Suchet" />
					</h4>
					<!-- <VirtualKeyboard /> -->
					<div id="noske-search" class="text-left"></div>
					<div id="example" class="cursor-pointer py-4">
						<strong
							><span class="arrow inline-block text-red-600">&#8595;</span>&nbsp;<h5 class="inline">
								Beispiele
							</h5>&nbsp;<span class="arrow inline-block text-red-600">&#8595;</span></strong
						>
					</div>
					<div id="examplelist" class="hidden text-left">
						<h6>Einfache Suche</h6>
						<ul>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">"Feeg=Feuer"</a>: Suche nach einem
								Wort im Volltext
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">"arme Seelen"</a>: Suche nach zwei
								aufeinanderfolgenden Wörtern
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">"in dem Feegfeuer"</a>: Suche nach
								drei aufeinanderfolgenden Wörtern
							</li>
						</ul>
						<br />
						<h6>Erweiterte Suche (CQL)</h6>

						<ul>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">[w="Feegfeuer"]</a>: Suche nach einer
								Wortform, hier: "Feeg=Feuer"
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">[l="Fegefeuer"]</a>: Suche nach einem
								Lemma, hier: "Fegefeuer"
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">[l="ja" &amp; pos="PTKANT"]</a>:
								Suche nach einer Wortart mit den Tags des Stuttgart-Tübingen-TagSets, hier:
								Antwortpartikel
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">[pos="NN" &amp; l=".*feuer"]</a>:
								Suche nach einer Wortart kombiniert mit einem Lemma, das mit einem bestimmten
								Wortteil endet, hier: Nomen mit "-feuer"
							</li>
							<li class="cursor-pointer px-2">
								<a class="hit-examples text-red-600 underline">[pos="ADJA"] [l="Fegefeuer"]</a>:
								Suche nach einer Sequenz bestehend aus einer Wortart und einem Lemma, hier: Adjektiv
								und "Fegefeuer"
							</li>
							<li class="px-2">
								Weitere Hinweise zur Abfragesyntax finden Sie <a
									href="nutzung"
									class="text-red-600 underline">hier</a
								>.
							</li>
						</ul>
					</div>
				</div>
			</div>
			<div id="hitsbox"></div>

			<div class="mx-auto grid grid-cols-2">
				<div id="noske-pagination" class="text-right"></div>
				<div id="statsbox" class="text-left"></div>
			</div>
		</div>
		<EditionFragment />
	</div>
</div>

<style is:global>
	.bg-abacus-search {
		max-width: 44px;
		background-image: url("/suchlupe.jpg");
		background-position: center;
		background-size: cover;
		background-repeat: no-repeat;
	}

	.kwic.active {
		border-bottom: 1px solid rgb(239 68 68);
	}
</style>
<script>
	import { NoskeSearch } from "acdh-noske-search";
	import { loadContent } from "../lib/synopticView";

	const screeWidth = window.innerWidth >= 1024 ? true : false;

	// Helper function to escape special regex characters
	const escapeRegex = (str: string): string => {
		return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
	};

	const search = new NoskeSearch({
		container: "noske-search",
		autocomplete: true,
		wordlistattr: [
			"word",
			"lemma",
			"w",
			"l",
			"pos",
			"id",
			"placeName",
			"placeType",
			"persName",
			"persType",
			"pbId",
			"pbN",
		],
	});

	search.minQueryLength = 2;

	// Add virtual keyboard to noske-input after it's created
	window.addEventListener("load", () => {
		// Check URL parameters for "seite" parameter
		const urlParams = new URLSearchParams(window.location.search);
		const seiteValue = urlParams.get("seite");

		if (seiteValue) {
			// Use the seite value here
			console.log("Seite parameter found:", seiteValue);
			// You can add your logic here to use the seiteValue
			loadContent(seiteValue, "noske-synoptic-view", "", "");
		}

		const noskeInputDiv = document.getElementById("noske-input");
		if (noskeInputDiv) {
			const virtualKeyboardHtml = `
				<div class="font-segoe text-gray-600">
					<form class="flex items-center">
						<span
							class="pl-2 relative w-[90%] overflow-visible rounded-sm bg-white font-antiqua flex items-center"
							id="input-query"
							><input
								type="checkbox"
								value="unused"
								class="absolute opacity-0 pointer-events-none"
								id="vkbtquery"
							/><label
								for="vkbtquery"
								class="cursor-pointer flex items-center flex-shrink-0"
								><img src="/virtualkeyboard.jpg" alt="Sonderzeichen einfügen" title="Sonderzeichen einfügen" class="shadow-lg h-[42px] w-[42px] flex-shrink-0"/></label
							><ul
								id="vkbtquerymenu"
								role="menu"
								class="absolute bottom-0 left-14 z-50 m-0 mt-[8px] hidden list-none whitespace-nowrap border border-gray-300 bg-white p-0.5"
								data-context="abacus"
							>
								<li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ä
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ā
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									â
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									æ
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ë
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									e̅
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									m̅
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									n̅
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									œ
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ö
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ü
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									ß
								</li><li
									role="menuitem"
									class="m-1 inline-block w-8 cursor-default bg-gray-300 pl-0 text-center shadow-md"
								>
									'
								</li>
							</ul></span
						>
					</form>
				</div>
			`;

			noskeInputDiv.insertAdjacentHTML("beforeend", virtualKeyboardHtml);

			// Add event listeners for the virtual keyboard
			const vkbtlabel = document.getElementById("vkbtquery");
			const vkbtmenu = document.getElementById("vkbtquerymenu");
			vkbtlabel?.addEventListener("click", () => {
				vkbtmenu?.classList.toggle("hidden");
			});
			const vkbtmenuitems = document.querySelectorAll("#vkbtquerymenu li");
			vkbtmenuitems.forEach((item) => {
				item.addEventListener("click", (e) => {
					const noskeInput = document.getElementById("noske-input-input") as HTMLInputElement;
					// @ts-ignore
					noskeInput.value += e.target!.textContent?.trim() || "";
					noskeInput.dispatchEvent(new Event("input", { bubbles: true }));
				});
			});
		}
	});

	search.search({
		debug: false,
		client: {
			//base: "http://localhost:8080",
			base: "https://abacus-noske.acdh-dev.oeaw.ac.at",
			corpname: "abacus",
			attrs: "word,lemma,w,l,pos,id,placeName,placeType,persName,persType,pbId,pbN",
			structs: "doc,g",
			refs: "doc.title,doc.id",
		},
		hits: {
			id: "hitsbox",
			css: {
				div: "p-5 grid grid-cols-1 gap-2 sm:grid-cols-1 md:grid-cols-1 lg:grid-cols-1 xl:grid-cols-1 xs:grid-cols-1",
				table: "table-auto",
				kwic: "text-red-500 text-lg",
				trHead: "bg-gray-200",
			},
		},
		searchInput: {
			id: "noske-input",
			placeholder: "Tippe zumindest zwei Zeichen um Wortvorschläge zu erhalten...",
			button: "Suchen",
			css: {
				button: "text-xl bg-abacus-search text-transparent shadow-lg border-gray-300 ",
			},
		},
		pagination: {
			id: "noske-pagination",
			css: {
				select: "rounded-lg text-xl p-2",
			},
		},
		stats: {
			id: "statsbox",
			customQueryStats: async (query, lines, pagesize, containerId) => {
				// function timeout
				// const timeout = (ms: number) => new Promise((resolve) => setTimeout(resolve, ms));
				// await timeout(250); // wait for hits to be rendered
				let issues = {};
				for (const line of lines) {
					var issueId = line.refs[1].split("doc.id=")[1];
					issues["Korpus"] ? issues["Korpus"]++ : (issues["Korpus"] = 1);
					issues[issueId] ? issues[issueId]++ : (issues[issueId] = 1);
				}
				const issuesBox = document.createElement("div");
				issuesBox.classList.add("mt-4", "text-gray-600", "text-left");
				issuesBox.innerHTML = `<img class="inline" src="/ihr_findet_padded.jpg" alt="Ihr findet" title="Ihr findet"/><h4 class="text-lg">Anzahl der Treffer:</h4>`;
				issuesBox.innerHTML += `<ul class="pl-4">`;
				for (const [key, value] of Object.entries(issues)) {
					let title = key.replaceAll("_", " ").replace("Abraham-", "").replace("oe", "ö");
					issuesBox.innerHTML += `<li class="text-red-600 cursor-pointer list-none" data-key="${key == "Korpus" ? ".*" : key}">${value} – ${title}</li>`;
				}
				const hitsBox =
					document.getElementById(containerId!) || document.getElementById("hitsbox-init");
				hitsBox!.prepend(issuesBox);

				issuesBox.addEventListener("click", (e) => {
					// @ts-ignore
					const key = e.target!.dataset.key;
					if (key) {
						let searchInput = document.getElementById("noske-input-input") as HTMLInputElement;
						let searchSelect = document.getElementById("noske-input-select") as HTMLSelectElement;
						if (searchInput.value.includes("within")) {
							if (searchSelect.value !== "cql") {
								searchSelect.value = "cql";
								let searchInputValue = searchInput.value.replace(
									/(.+) within .+/g,
									`"$1" within <doc id="${key}"/>`,
								);
								searchInput.value = searchInputValue;
							} else {
								searchInput.value = searchInput.value.replace(
									/(.+) within .+/g,
									`$1 within <doc id="${key}"/>`,
								);
							}
						} else {
							if (searchSelect.value !== "cql") {
								searchSelect.value = "cql";
								let searchInputValue = searchInput.value.replace(
									/(.+)/g,
									`"$1" within <doc id="${key}"/>`,
								);
								searchInput.value = searchInputValue;
							} else {
								searchInput.value = searchInput.value.replace(
									/(.+)/g,
									`$1 within <doc id="${key}"/>`,
								);
							}
						}
						const searchButton = document.getElementById(
							"noske-search-button",
						) as HTMLButtonElement;
						searchButton.click();
					}
				});
			},
			label: "Ergebnisse:",
			css: {
				label: "text-lg text-gray-600 pt-2",
			},
		},
		autocompleteOptions: {
			id: "noske-autocomplete",
			regexType: "startsWith",
			css: {
				div: "bg-white border border-gray-300 absolute ml-[145px] mt-10 text-left overflow-y-scroll overflow-x-hidden max-h-[400px]",
				ul: "p-0",
				li: "p-2 hover:bg-gray-100 text-sm text-gray-500 hover:cursor-pointer",
				loader:
					"m-2 border-4 border-gray-300 border-t-4 border-t-black rounded-full relative w-[40px] h-[40px] text-center",
			},
		},
		config: {
			tableView: false,
			customUrlTransform: screeWidth
				? undefined
				: (lines: { kwic_attr?: string }) => {
						let kwic_attr = lines.kwic_attr?.split("/")[1];
						let pageId = lines.kwic_attr?.split("/")[8];
						// let refs = lines.refs;
						// let docID = refs[0].split("=")[1];
						let url = new URL("https://abacus.acdh-ch-dev.oeaw.ac.at/edition/" + pageId);
						url.hash = kwic_attr!;
						url.searchParams.set("img", "on");
						url.searchParams.set("place", "on");
						return url;
					},
			customResponseHtml: (lines: any, containerId: string, hits: any, client_attrs: any) => {
				const hitsBox = document.getElementById(containerId);

				const attr = lines[0].kwic_attr?.split("/");
				attr!.shift();
				let attr_length = attr!.length / 11;
				let pdIdx = 9;
				let pdNdx = 10;
				if (attr_length > 1) {
					for (let i = 1; i < attr_length; i++) {
						if (attr![pdIdx] !== "" && attr![pdNdx] !== "") {
							pdIdx += 0;
							pdNdx += 0;
						} else {
							pdIdx += 11;
							pdNdx += 11;
						}
					}
				}
				let pdId = attr![pdIdx];
				let pdN = attr![pdNdx];
				let hash = pdId!.split("__")[2];
				loadContent(pdId, "noske-synoptic-view", hash, pdN);

				let issues = {};

				let count = 0;
				for (const line of lines) {
					const hitItem = document.createElement("div");
					hitItem!.classList.add(...["mt-4", "kwic", "cursor-pointer", "text-left", "border-b"]);

					// Set first item as active since its data is already loaded
					if (count === 0 && screeWidth) {
						hitItem.classList.add("active");
					}

					let hitId = line.kwic_attr.split("/")[8];
					// let docTitle = line.refs[1].split("doc.id=")[1];
					// hitId = `line-${count}__${docTitle}__${hitId}`;
					hitItem.id = hitId;

					// let hitCss = hits.css.div.split(" ");
					// hitItem.classList.add(...hitCss);

					const context = document.createElement("div");
					context.classList.add("flex", "items-center");
					context.style.fontSize = "1em";
					context.style.color = "#454545";

					const searchIcon = document.createElement("span");
					searchIcon.style.marginRight = "2em";
					searchIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-search" viewBox="0 0 16 16">
                <path d="M11.742 10.344a6.5 6.5 0 1 0-1.397 1.398h-.001q.044.06.098.115l3.85 3.85a1 1 0 0 0 1.415-1.414l-3.85-3.85a1 1 0 0 0-.115-.1zM12 6.5a5.5 5.5 0 1 1-11 0 5.5 5.5 0 0 1 11 0"/>
                </svg>`;
					searchIcon.style.color = "#454545";
					context.appendChild(searchIcon);

					const left = document.createElement("span");
					left.style.color = "#454545";
					let leftKwic = line.left.split(" ").reverse().slice(0, 4).reverse().join(" ");
					left.innerHTML = `...${leftKwic}`;
					context.appendChild(left);

					const kwic = document.createElement("span");
					kwic.style.padding = "0 0.5em";
					let kwicCss = hits.css.kwic.split(" ");
					kwic.classList.add(...kwicCss);
					kwic.classList.add("text-red-600");
					kwic.innerHTML = line.kwic;
					context.appendChild(kwic);

					const right = document.createElement("span");
					right.style.color = "#454545";
					let rightKwic = line.right.split(" ").slice(0, 4).join(" ");
					right.innerHTML = ` ${rightKwic}...`;
					context.appendChild(right);

					hitItem.append(context);

					const issue = document.createElement("div");
					issue.classList.add("flex", "items-center");
					// issue.style.borderBottom = "1px solid #e0e0e0";
					issue.style.padding = "0 0 1em 0";
					issue.style.color = "#454545";

					const issueIcon = document.createElement("span");
					issueIcon.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-file-earmark" viewBox="0 0 16 16">
                                    <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5z"/>
                                    </svg>`;
					issueIcon.style.color = "#454545";
					issueIcon.style.marginRight = "2em";
					issue.appendChild(issueIcon);

					let kwic_attr = line.kwic_attr.split(" ");
					let pageAttr = kwic_attr[0].split("/")[11];

					var facs = line.refs[0].replace("doc.title=", "");
					var issueId = line.refs[1].split("doc.id=")[1];

					issues["Corpus"] ? issues["Corpus"]++ : (issues["Corpus"] = 1);
					issues[issueId] ? issues[issueId]++ : (issues[issueId] = 1);

					try {
						var pageNr: string = pageAttr.replaceAll("_", " ").replace(/[\[\]]/g, "");
					} catch (error) {
						var pageNr = "S. 1";
						console.log("No issue in kwic_attr", issue);
					}

					var page = document.createElement("span");
					page.classList.add("text-red-600");
					page.classList.add(...["page"]);

					try {
						page.innerHTML = `${pageNr} – ${facs.replace("Abraham-", "").replace("oe", "ö")}`;
					} catch (error) {
						page.innerHTML = "TITEL S. 1";
					}

					const arrow = document.createElement("span");
					arrow.style.marginLeft = "1em";
					arrow.classList.add("text-red-600");
					// arrow.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" class="bi bi-arrow-right" viewBox="0 0 16 16">
					//                           <path fill-rule="evenodd" d="M1 8a.5.5 0 0 1 .5-.5h11.793l-3.147-3.146a.5.5 0 0 1 .708-.708l4 4a.5.5 0 0 1 0 .708l-4 4a.5.5 0 0 1-.708-.708L13.293 8.5H1.5A.5.5 0 0 1 1 8"/>
					//                           </svg>`;
					arrow.innerHTML = "&#8594;";
					issue.appendChild(page);
					issue.appendChild(arrow);

					hitItem.appendChild(issue);

					hitsBox!.appendChild(hitItem);
					count++;

					if (screeWidth) {
						hitItem.addEventListener("click", () => {
							let active = document.querySelectorAll(".kwic.active");
							active.forEach((element) => {
								element.classList.remove("active");
							});
							hitItem.classList.toggle("active");
							// console.log(line);
							let attr = line.kwic_attr?.split("/");
							attr!.shift();
							let attr_length = attr!.length / 11;
							let pdIdx = 9;
							let pdNdx = 10;
							if (attr_length > 1) {
								for (let i = 1; i < attr_length; i++) {
									if (attr![pdIdx] !== "" && attr![pdNdx] !== "") {
										pdIdx += 0;
										pdNdx += 0;
									} else {
										pdIdx += 11;
										pdNdx += 11;
									}
								}
							}
							let pdId = attr![pdIdx];
							let pdN = attr![pdNdx];
							let hash = hitId.split("__")[2];
							loadContent(pdId, "noske-synoptic-view", hash, pdN);
						});
					}
				}
			},
			// customSynopticView: screeWidth
			// 	? (resultLineId: any) => {
			// 			let first_entry: [string, any] = Object.entries(resultLineId)[0];
			// 			if (first_entry) {
			// 				let key = first_entry[0];
			// 				let value = first_entry[1];
			// 				let kwic = document.getElementById(key) as HTMLElement;
			// 				kwic?.classList.add("active");
			// 				let attr = value!.kwic_attr?.split("/");
			// 				let pdId = attr![attr!.length - 2];
			// 				let pdN = attr![attr!.length - 1];
			// 				let hash = key.split("__")[2];
			// 				loadContent(pdId, "noske-synoptic-view", hash, pdN);
			// 			}
			// 			const input = document.querySelector("#noske-input input") as HTMLInputElement;
			// 			input?.addEventListener("input", (e) => {
			// 				// @ts-ignore
			// 				if (e.target?.value === "") {
			// 					let view = document.getElementById("noske-synoptic-view") as HTMLElement;
			// 					view?.parentElement!.classList.toggle("hidden");
			// 					view?.parentElement!.classList.toggle("active");
			// 				}
			// 			});
			// 			Object.entries(resultLineId).forEach(([key, value]) => {
			// 				console.log(key, value);
			// 				let kwic = document.getElementById(key) as HTMLElement;
			// 				kwic?.classList.add("kwic");
			// 				kwic?.addEventListener("click", () => {
			// 					let active = document.querySelectorAll(".kwic.active");
			// 					active.forEach((element) => {
			// 						element.classList.remove("active");
			// 					});
			// 					kwic?.classList.add("active");
			// 					let attr = value!.kwic_attr?.split("/");
			// 					let pdId = attr![attr!.length - 2];
			// 					let pdN = attr![attr!.length - 1];
			// 					let hash = key.split("__")[2];
			// 					// let id = key.split("__")[1];
			// 					loadContent(pdId, "noske-synoptic-view", hash, pdN);
			// 				});
			// 			});
			// 		}
			// 	: undefined,
		},
	});

	// Register people/places click handlers
	const registerpeopleplaces = document.querySelectorAll(
		"#rg-pers ul li , #rg-place ul li",
	) as NodeListOf<HTMLElement>;

	Array.from(registerpeopleplaces).forEach((item) => {
		item.addEventListener("click", (e) => {
			// Reset all other LI elements to normal weight
			registerpeopleplaces.forEach((li) => {
				li.style.fontWeight = "normal";
			});

			// Make clicked item bold
			item.style.fontWeight = "bold";

			const noskeInput = document.getElementById("noske-input-input") as HTMLInputElement;
			const noskeSelect = document.getElementById("noske-input-select") as HTMLSelectElement;
			noskeSelect.value = "cql";

			// Determine attribute based on context - check parent element or use persName as default
			const parentId = item.closest("div")?.id || "";
			const attribute = parentId.includes("place") ? "placeName" : "persName";

			// Use the item (li element) instead of e.target to get the data-str
			noskeInput.value = `[${attribute}="${item.dataset.str}"]`;
			const searchButton = document.getElementById("noske-search-button") as HTMLButtonElement;
			searchButton.click();
		});
	});

	// Register click handlers for person and place categories
	const registerPersType = document.querySelectorAll(
		"#persType, #placeType",
	) as NodeListOf<HTMLElement>;

	Array.from(registerPersType).forEach((item) => {
		item.addEventListener("click", (e) => {
			const noskeInput = document.getElementById("noske-input-input") as HTMLInputElement;
			const noskeSelect = document.getElementById("noske-input-select") as HTMLSelectElement;
			noskeSelect.value = "cql";

			// Set attribute to persType
			const attribute = item.id === "persType" ? "persType" : "placeType";

			// Use the item to get the data-str
			noskeInput.value = `[${attribute}="${item.dataset.str}"]`;
			const searchButton = document.getElementById("noske-search-button") as HTMLButtonElement;
			searchButton.click();
		});
	});

	const hitExamples = document.querySelectorAll(".hit-examples") as NodeListOf<HTMLElement>;
	Array.from(hitExamples).forEach((item) => {
		item.addEventListener("click", (e) => {
			// @ts-ignore
			const key = e.target!.innerHTML.replace("&amp;", "&");

			if (key) {
				let searchInput = document.getElementById("noske-input-input") as HTMLInputElement;
				let searchSelect = document.getElementById("noske-input-select") as HTMLSelectElement;
				searchSelect.value = "cql";
				searchInput.value = key;
				const searchButton = document.getElementById("noske-search-button") as HTMLButtonElement;
				searchButton.click();
			}
		});
	});

	const wordlist = document.querySelectorAll("#abacus-wordslist ul li") as NodeListOf<HTMLElement>;
	const wordslistHtml = document.querySelector("#abacus-wordslist div") as HTMLDivElement;

	Array.from(wordlist).forEach((element) => {
		element.addEventListener("click", async () => {
			let id = element.id;

			// Special handling for persName - show registerPers instead of word list
			if (id === "persName") {
				const registerPers = document.getElementById("rg-pers");
				const registerPlace = document.getElementById("rg-place");
				registerPers!.classList.remove("hidden");
				registerPlace!.classList.add("hidden");

				wordslistHtml.classList.remove("hidden");
				wordslistHtml.classList.add("active");
				wordslistHtml.innerHTML = `<div class="relative"><input id="rg-filter" type="text" placeholder="Filter..." class="w-full rounded border border-gray-300 p-2" autocomplete="off" /><div id="rg-autocomplete" class="hidden absolute z-50 w-full bg-white border border-gray-300 mt-1 max-h-60 overflow-y-auto shadow-lg"></div></div><span id="rg-reset" class="cursor-pointer text-gray-500">zurücksetzen</span>`;

				// Add event listener for reset button in case persName was clicked
				const reset = document.getElementById("rg-reset") as HTMLElement;
				reset.addEventListener("click", () => {
					wordslistHtml.innerHTML = "";
					const registerPers = document.getElementById("rg-pers");
					registerPers!.classList.add("hidden");
					const registerPlace = document.getElementById("rg-place");
					registerPlace!.classList.add("hidden");

					// Hide all UL elements in rg-pers
					const rgPersUls = registerPers!.querySelectorAll("ul") as NodeListOf<HTMLElement>;
					rgPersUls.forEach((ul) => ul.classList.add("hidden"));

					// Reset font weights and display styles for all h5 and li elements
					const allH5 = document.querySelectorAll(
						"#rg-pers h5, #rg-place h5",
					) as NodeListOf<HTMLElement>;
					allH5.forEach((h5) => {
						h5.style.fontWeight = "normal";
						h5.style.display = "";
					});
					const allLi = document.querySelectorAll(
						"#rg-pers ul li, #rg-place ul li",
					) as NodeListOf<HTMLElement>;
					allLi.forEach((li) => {
						li.style.fontWeight = "normal";
						li.style.display = "";
					});
					const allUl = document.querySelectorAll(
						"#rg-pers ul, #rg-place ul",
					) as NodeListOf<HTMLElement>;
					allUl.forEach((ul) => {
						ul.style.display = "";
					});
					// Reset span and br elements
					const allSpan = document.querySelectorAll(
						"#rg-pers span, #rg-place span",
					) as NodeListOf<HTMLElement>;
					allSpan.forEach((span) => {
						span.style.display = "";
					});
					const allBr = document.querySelectorAll(
						"#rg-pers br, #rg-place br",
					) as NodeListOf<HTMLElement>;
					allBr.forEach((br) => {
						br.style.display = "";
					});
				});

				// Add event listener for filter with autocomplete
				const regfilter = document.getElementById("rg-filter") as HTMLInputElement;
				const autocompleteDiv = document.getElementById("rg-autocomplete") as HTMLElement;
				let debounceTimer: number;
				let selectedIndex = -1;
				let skipAutocomplete = false;

				// Collect all person names for autocomplete
				const allPersonNames: string[] = [];
				const allContainers = Array.from(
					document.querySelectorAll("#rg-pers") as NodeListOf<HTMLElement>,
				);
				allContainers.forEach((container) => {
					const listItems = container.querySelectorAll("li") as NodeListOf<HTMLElement>;
					listItems.forEach((li) => {
						const text = li.textContent?.trim() || "";
						if (text) allPersonNames.push(text);
					});
				});

				regfilter.addEventListener("input", () => {
					clearTimeout(debounceTimer);
					debounceTimer = window.setTimeout(() => {
						const filterValue = regfilter.value.toLowerCase();
						const escapedFilterValue = escapeRegex(filterValue);
						const regex = filterValue ? new RegExp(escapedFilterValue, "i") : null;
						selectedIndex = -1;

						// Show autocomplete suggestions only if not skipping
						if (!skipAutocomplete && filterValue && filterValue.length >= 2) {
							const matches = allPersonNames.filter((name) => regex?.test(name)).slice(0, 10);
							if (matches.length > 0) {
								autocompleteDiv.innerHTML = matches
									.map(
										(name, idx) =>
											`<div class="p-2 hover:bg-gray-100 cursor-pointer autocomplete-item" data-index="${idx}">${name}</div>`,
									)
									.join("");
								autocompleteDiv.classList.remove("hidden");
							} else {
								autocompleteDiv.classList.add("hidden");
							}
						} else {
							autocompleteDiv.classList.add("hidden");
						}

						// Always reset skip flag after processing one input event
						skipAutocomplete = false;

						// Filter display
						allContainers.forEach((container) => {
							const h5Elements = container.querySelectorAll("h5") as NodeListOf<HTMLElement>;

							h5Elements.forEach((h5Element) => {
								// Find the next UL sibling and collect span/br elements after h5
								let nextUl = h5Element.nextElementSibling;
								const elementsToToggle: HTMLElement[] = [];
								while (nextUl && nextUl.tagName !== "UL") {
									if (nextUl.tagName === "SPAN" || nextUl.tagName === "BR") {
										elementsToToggle.push(nextUl as HTMLElement);
									}
									nextUl = nextUl.nextElementSibling;
								}
								if (nextUl) {
									const ulElement = nextUl as HTMLElement;
									const listItems = ulElement.querySelectorAll("li") as NodeListOf<HTMLElement>;
									let hasVisibleItems = false;

									listItems.forEach((li) => {
										if (!regex) {
											li.style.display = "";
										} else {
											const text = li.textContent?.toLowerCase() || "";
											if (regex.test(text)) {
												li.style.display = "";
												hasVisibleItems = true;
											} else {
												li.style.display = "none";
											}
										}
									});

									if (!regex) {
										h5Element.style.display = "";
										h5Element.style.fontWeight = "normal";
										elementsToToggle.forEach((el) => (el.style.display = ""));
										ulElement.style.display = "none";
										ulElement.classList.add("hidden");
									} else if (hasVisibleItems) {
										h5Element.style.display = "";
										elementsToToggle.forEach((el) => (el.style.display = ""));
										ulElement.style.display = "";
										ulElement.classList.remove("hidden");
									} else {
										h5Element.style.display = "none";
										elementsToToggle.forEach((el) => (el.style.display = "none"));
										ulElement.style.display = "none";
									}
								}
							});
						});
					}, 150);
				});

				// Autocomplete item click handler
				autocompleteDiv.addEventListener("click", (e) => {
					const target = e.target as HTMLElement;
					if (target.classList.contains("autocomplete-item")) {
						skipAutocomplete = true;
						regfilter.value = target.textContent || "";
						autocompleteDiv.classList.add("hidden");
						regfilter.dispatchEvent(new Event("input"));
					}
				});

				// Keyboard navigation
				regfilter.addEventListener("keydown", (e) => {
					// Reset skip flag when user starts typing
					if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") {
						skipAutocomplete = false;
					}

					const items = autocompleteDiv.querySelectorAll(
						".autocomplete-item",
					) as NodeListOf<HTMLElement>;
					if (items.length === 0) return;

					if (e.key === "ArrowDown") {
						e.preventDefault();
						selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
						updateSelection(items, selectedIndex);
					} else if (e.key === "ArrowUp") {
						e.preventDefault();
						selectedIndex = Math.max(selectedIndex - 1, -1);
						updateSelection(items, selectedIndex);
					} else if (e.key === "Enter" && selectedIndex >= 0) {
						e.preventDefault();
						skipAutocomplete = true;
						regfilter.value = items[selectedIndex].textContent || "";
						autocompleteDiv.classList.add("hidden");
						regfilter.dispatchEvent(new Event("input"));
					} else if (e.key === "Escape") {
						autocompleteDiv.classList.add("hidden");
						selectedIndex = -1;
					}
				});

				function updateSelection(items: NodeListOf<HTMLElement>, index: number) {
					items.forEach((item, idx) => {
						if (idx === index) {
							item.classList.add("bg-gray-200");
						} else {
							item.classList.remove("bg-gray-200");
						}
					});
				}
				return;
			}

			// Special handling for placeName - show registerPlace instead of word list
			if (id === "placeName") {
				const registerPers = document.getElementById("rg-pers");
				const registerPlace = document.getElementById("rg-place");
				registerPlace!.classList.remove("hidden");
				registerPers!.classList.add("hidden");

				// Add reset button and show the wordslist div
				wordslistHtml.classList.remove("hidden");
				wordslistHtml.classList.add("active");
				wordslistHtml.innerHTML = `<div class="relative"><input id="rg-filter" type="text" placeholder="Filter..." class="w-full rounded border border-gray-300 p-2" autocomplete="off" /><div id="rg-autocomplete" class="hidden absolute z-50 w-full bg-white border border-gray-300 mt-1 max-h-60 overflow-y-auto shadow-lg"></div></div><span id="rg-reset" class="cursor-pointer text-gray-500">zurücksetzen</span>`;

				// Add event listener for reset button in case placeName was clicked
				const reset = document.getElementById("rg-reset") as HTMLElement;
				reset.addEventListener("click", () => {
					wordslistHtml.innerHTML = "";
					const registerPers = document.getElementById("rg-pers");
					registerPers!.classList.add("hidden");
					const registerPlace = document.getElementById("rg-place");
					registerPlace!.classList.add("hidden");

					// Hide all UL elements in rg-place
					const rgPlaceUls = registerPlace!.querySelectorAll("ul") as NodeListOf<HTMLElement>;
					rgPlaceUls.forEach((ul) => ul.classList.add("hidden"));

					// Reset font weights and display styles for all h5 and li elements
					const allH5 = document.querySelectorAll(
						"#rg-pers h5, #rg-place h5",
					) as NodeListOf<HTMLElement>;
					allH5.forEach((h5) => {
						h5.style.fontWeight = "normal";
						h5.style.display = "";
					});
					const allLi = document.querySelectorAll(
						"#rg-pers ul li, #rg-place ul li",
					) as NodeListOf<HTMLElement>;
					allLi.forEach((li) => {
						li.style.fontWeight = "normal";
						li.style.display = "";
					});
					const allUl = document.querySelectorAll(
						"#rg-pers ul, #rg-place ul",
					) as NodeListOf<HTMLElement>;
					allUl.forEach((ul) => {
						ul.style.display = "";
					});
					// Reset span and br elements
					const allSpan = document.querySelectorAll(
						"#rg-pers span, #rg-place span",
					) as NodeListOf<HTMLElement>;
					allSpan.forEach((span) => {
						span.style.display = "";
					});
					const allBr = document.querySelectorAll(
						"#rg-pers br, #rg-place br",
					) as NodeListOf<HTMLElement>;
					allBr.forEach((br) => {
						br.style.display = "";
					});
				});

				// Add event listener for filter with autocomplete
				const regfilter = document.getElementById("rg-filter") as HTMLInputElement;
				const autocompleteDiv = document.getElementById("rg-autocomplete") as HTMLElement;
				let debounceTimer: number;
				let selectedIndex = -1;
				let skipAutocomplete = false;

				// Collect all place names for autocomplete
				const allPlaceNames: string[] = [];
				const allContainers = Array.from(
					document.querySelectorAll("#rg-place") as NodeListOf<HTMLElement>,
				);
				allContainers.forEach((container) => {
					const listItems = container.querySelectorAll("li") as NodeListOf<HTMLElement>;
					listItems.forEach((li) => {
						const text = li.textContent?.trim() || "";
						if (text) allPlaceNames.push(text);
					});
				});

				regfilter.addEventListener("input", () => {
					clearTimeout(debounceTimer);
					debounceTimer = window.setTimeout(() => {
						const filterValue = regfilter.value.toLowerCase();
						const escapedFilterValue = escapeRegex(filterValue);
						const regex = filterValue ? new RegExp(escapedFilterValue, "i") : null;
						selectedIndex = -1;

						// Show autocomplete suggestions only if not skipping
						if (!skipAutocomplete && filterValue && filterValue.length >= 2) {
							const matches = allPlaceNames.filter((name) => regex?.test(name)).slice(0, 10);
							if (matches.length > 0) {
								autocompleteDiv.innerHTML = matches
									.map(
										(name, idx) =>
											`<div class="p-2 hover:bg-gray-100 cursor-pointer autocomplete-item" data-index="${idx}">${name}</div>`,
									)
									.join("");
								autocompleteDiv.classList.remove("hidden");
							} else {
								autocompleteDiv.classList.add("hidden");
							}
						} else {
							autocompleteDiv.classList.add("hidden");
						}

						// Always reset skip flag after processing one input event
						skipAutocomplete = false;

						// Filter display
						allContainers.forEach((container) => {
							const h5Elements = container.querySelectorAll("h5") as NodeListOf<HTMLElement>;

							h5Elements.forEach((h5Element) => {
								// Find the next UL sibling and collect span/br elements after h5
								let nextUl = h5Element.nextElementSibling;
								const elementsToToggle: HTMLElement[] = [];
								while (nextUl && nextUl.tagName !== "UL") {
									if (nextUl.tagName === "SPAN" || nextUl.tagName === "BR") {
										elementsToToggle.push(nextUl as HTMLElement);
									}
									nextUl = nextUl.nextElementSibling;
								}
								if (nextUl) {
									const ulElement = nextUl as HTMLElement;
									const listItems = ulElement.querySelectorAll("li") as NodeListOf<HTMLElement>;
									let hasVisibleItems = false;

									listItems.forEach((li) => {
										if (!regex) {
											li.style.display = "";
										} else {
											const text = li.textContent?.toLowerCase() || "";
											if (regex.test(text)) {
												li.style.display = "";
												hasVisibleItems = true;
											} else {
												li.style.display = "none";
											}
										}
									});

									if (!regex) {
										h5Element.style.display = "";
										h5Element.style.fontWeight = "normal";
										elementsToToggle.forEach((el) => (el.style.display = ""));
										ulElement.style.display = "none";
										ulElement.classList.add("hidden");
									} else if (hasVisibleItems) {
										h5Element.style.display = "";
										elementsToToggle.forEach((el) => (el.style.display = ""));
										ulElement.style.display = "";
										ulElement.classList.remove("hidden");
									} else {
										h5Element.style.display = "none";
										elementsToToggle.forEach((el) => (el.style.display = "none"));
										ulElement.style.display = "none";
									}
								}
							});
						});
					}, 150);
				});

				// Autocomplete item click handler
				autocompleteDiv.addEventListener("click", (e) => {
					const target = e.target as HTMLElement;
					if (target.classList.contains("autocomplete-item")) {
						skipAutocomplete = true;
						regfilter.value = target.textContent || "";
						autocompleteDiv.classList.add("hidden");
						regfilter.dispatchEvent(new Event("input"));
					}
				});

				// Keyboard navigation
				regfilter.addEventListener("keydown", (e) => {
					// Reset skip flag when user starts typing
					if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") {
						skipAutocomplete = false;
					}

					const items = autocompleteDiv.querySelectorAll(
						".autocomplete-item",
					) as NodeListOf<HTMLElement>;
					if (items.length === 0) return;

					if (e.key === "ArrowDown") {
						e.preventDefault();
						selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
						updateSelection(items, selectedIndex);
					} else if (e.key === "ArrowUp") {
						e.preventDefault();
						selectedIndex = Math.max(selectedIndex - 1, -1);
						updateSelection(items, selectedIndex);
					} else if (e.key === "Enter" && selectedIndex >= 0) {
						e.preventDefault();
						skipAutocomplete = true;
						regfilter.value = items[selectedIndex].textContent || "";
						autocompleteDiv.classList.add("hidden");
						regfilter.dispatchEvent(new Event("input"));
					} else if (e.key === "Escape") {
						autocompleteDiv.classList.add("hidden");
						selectedIndex = -1;
					}
				});

				function updateSelection(items: NodeListOf<HTMLElement>, index: number) {
					items.forEach((item, idx) => {
						if (idx === index) {
							item.classList.add("bg-gray-200");
						} else {
							item.classList.remove("bg-gray-200");
						}
					});
				}
				return;
			}

			let words = await search.getWordsList({
				corpname: "abacus",
				wlattr: id,
				includeNonwords: 0,
				wlicase: 0,
				wltype: "simple",
				wlmaxitems: 3600,
				wlminfreq: 1,
			});

			if (wordslistHtml.classList.contains("active")) {
				wordslistHtml.innerHTML = "";
				const registerPers = document.getElementById("rg-pers");
				registerPers!.classList.add("hidden");
				const registerPlace = document.getElementById("rg-place");
				registerPlace!.classList.add("hidden");
			} else {
				wordslistHtml.classList.toggle("hidden");
				wordslistHtml.classList.toggle("active");
			}

			// @ts-ignore
			const wordlist = [...words.Items].filter((item) => item.str !== "");

			// Custom sorting functions for diacritics-aware sorting
			const diacriticSort = (a: string, b: string): number => {
				const normalize = (str: string) => str.normalize("NFD").replace(/[\u0300-\u036f]/g, "");
				return normalize(a).localeCompare(normalize(b));
			};

			const normalizeFirstLetter = (str: string): string => {
				const normalized = str
					.charAt(0)
					.normalize("NFD")
					.replace(/[\u0300-\u036f]/g, "");
				return normalized.toUpperCase();
			};

			wordslistHtml.innerHTML = `<div class="relative"><input id="rg-filter" type="text" placeholder="Filter..." class="w-full rounded border border-gray-300 p-2" autocomplete="off" /><div id="rg-autocomplete" class="hidden absolute z-50 w-full bg-white border border-gray-300 mt-1 max-h-60 overflow-y-auto shadow-lg"></div></div><span id="rg-reset" class="cursor-pointer text-gray-500">zurücksetzen</span>`;

			if (id !== "pos") {
				let abc: {
					[key: string]: Array<string>;
				} = {};

				wordlist.map((item) => {
					let firstLetter: string = normalizeFirstLetter(item.str);

					pushOrCreate(abc, firstLetter, item);
				});

				// Sort sections by normalized keys and words within each section using diacriticSort
				const sortedSections = Object.entries(abc).sort((a, b) => diacriticSort(a[0], b[0]));
				for (const [key, value] of sortedSections) {
					const sortedWords = value.sort((a, b) => diacriticSort(a, b));
					wordslistHtml.innerHTML += `<div id="rg-abc"><h4 class="cursor-pointer"><span class="text-red-600">&#8595; </span>${key}</h4><ul class="hidden pl-2">${sortedWords.join("")}</ul></div>`;
				}
			} else {
				let wordTypes: {
					[key: string]: Array<string>;
				} = {};

				wordlist.map((item) => {
					if (item.str.includes("_")) {
						pushOrCreate(wordTypes, "Kontrahierte-Formen-II", item);
					} else if (
						item.str.includes("PPER") ||
						item.str.includes("ARTNN") ||
						item.str.includes("ADVART")
					) {
						if (item.str.startsWith("P")) {
							pushOrCreate(wordTypes, "Pronomen-mit-Klitikon", item);
						} else if (item.str.startsWith("V")) {
							pushOrCreate(wordTypes, "Verb-mit-Klitikon", item);
						} else if (item.str.startsWith("ADV")) {
							pushOrCreate(wordTypes, "Adverb-mit-Klitikon", item);
						} else if (item.str.startsWith("ART")) {
							pushOrCreate(wordTypes, "Nomen-mit-Klitikon", item);
						} else if (item.str.startsWith("KOU")) {
							pushOrCreate(wordTypes, "Konjunktion-mit-Klitikon", item);
						}
					} else {
						pushOrCreate(wordTypes, "Stuttgart-Tübingen-TagSet", item);
					}
				});

				wordslistHtml.innerHTML += `<div id="rg-abc"><h4 class="cursor-pointer"><span class="text-red-600">&#8595; </span>Kontrahierte Formen I</h4><ul class="hidden pl-2" id="rg-abc-types"></ul></div>`;

				// Sort word types using diacriticSort
				const sortedWordTypes = Object.entries(wordTypes).sort((a, b) => diacriticSort(a[0], b[0]));
				for (let [key, value] of sortedWordTypes) {
					const sortedWords = value.sort((a, b) => diacriticSort(a, b));
					if (key !== "Kontrahierte-Formen-II" && key !== "Stuttgart-Tübingen-TagSet") {
						document.getElementById("rg-abc-types")!.innerHTML +=
							`<h4 class="cursor-pointer"><span class="text-red-600">&#8595; </span>${key.replace("-", " ").replace("-", " ")}</h4><ul class="hidden pl-2">${sortedWords.join("")}</ul>`;
					} else {
						if (key !== "Stuttgart-Tübingen-TagSet") {
							key = key.replace("-", " ").replace("-", " ");
						}
						wordslistHtml.innerHTML += `<div id="rg-abc"><h4 class="cursor-pointer"><span class="text-red-600">&#8595; </span>${key}</h4><ul class="hidden pl-2">${sortedWords.join("")}</ul></div>`;
					}
				}
			}

			// Event listener for reset button
			const reset = document.getElementById("rg-reset") as HTMLElement;
			reset.addEventListener("click", () => {
				wordslistHtml.innerHTML = "";
				const registerPers = document.getElementById("rg-pers");
				registerPers!.classList.add("hidden");
				const registerPlace = document.getElementById("rg-place");
				registerPlace!.classList.add("hidden");

				// Reset font weights and display styles for all h4, h5 and li elements
				const allH4 = document.querySelectorAll("#rg-abc h4") as NodeListOf<HTMLElement>;
				allH4.forEach((h4) => {
					h4.style.fontWeight = "normal";
					h4.style.display = "";
				});
				const allH5 = document.querySelectorAll(
					"#rg-pers h5, #rg-place h5",
				) as NodeListOf<HTMLElement>;
				allH5.forEach((h5) => {
					h5.style.fontWeight = "normal";
					h5.style.display = "";
				});
				const allLi = document.querySelectorAll(
					"#abacus-wordslist div ul li, #rg-pers ul li, #rg-place ul li",
				) as NodeListOf<HTMLElement>;
				allLi.forEach((li) => {
					li.style.fontWeight = "normal";
					li.style.display = "";
				});
				const allUl = document.querySelectorAll(
					"#rg-pers ul, #rg-place ul, #rg-abc ul",
				) as NodeListOf<HTMLElement>;
				allUl.forEach((ul) => {
					ul.style.display = "";
				});
				// Reset span and br elements
				const allSpan = document.querySelectorAll(
					"#rg-pers span, #rg-place span",
				) as NodeListOf<HTMLElement>;
				allSpan.forEach((span) => {
					span.style.display = "";
				});
				const allBr = document.querySelectorAll(
					"#rg-pers br, #rg-place br",
				) as NodeListOf<HTMLElement>;
				allBr.forEach((br) => {
					br.style.display = "";
				});
			});

			// Add event listener for filter with autocomplete (for regular wordlist)
			const regfilter = document.getElementById("rg-filter") as HTMLInputElement;
			const autocompleteDiv = document.getElementById("rg-autocomplete") as HTMLElement;
			let debounceTimer: number;
			let selectedIndex = -1;
			let skipAutocomplete = false;

			// Collect all words for autocomplete
			const allWords: Array<{ str: string; frq: string }> = [];
			wordlist.forEach((item: any) => {
				allWords.push({ str: item.str, frq: item.frq });
			});

			regfilter.addEventListener("input", () => {
				clearTimeout(debounceTimer);
				debounceTimer = window.setTimeout(() => {
					const filterValue = regfilter.value.toLowerCase();
					const escapedFilterValue = escapeRegex(filterValue);
					const regex = filterValue ? new RegExp(escapedFilterValue, "i") : null;
					selectedIndex = -1;

					// Show autocomplete suggestions only if not skipping
					if (!skipAutocomplete && filterValue && filterValue.length >= 2) {
						const matches = allWords.filter((word) => regex?.test(word.str)).slice(0, 10);
						if (matches.length > 0) {
							autocompleteDiv.innerHTML = matches
								.map(
									(word, idx) =>
										`<div class="p-2 hover:bg-gray-100 cursor-pointer autocomplete-item text-red-600" data-index="${idx}" data-str="${word.str}">${word.str} (${word.frq})</div>`,
								)
								.join("");
							autocompleteDiv.classList.remove("hidden");
						} else {
							autocompleteDiv.classList.add("hidden");
						}
					} else {
						autocompleteDiv.classList.add("hidden");
					}

					// Always reset skip flag after processing one input event
					skipAutocomplete = false;

					// Get all rg-abc containers only (for regular wordlist)
					const allContainers = Array.from(
						document.querySelectorAll("#rg-abc") as NodeListOf<HTMLElement>,
					);

					allContainers.forEach((container) => {
						// Find all h4 elements (section headers) in this container
						const h4Elements = container.querySelectorAll("h4") as NodeListOf<HTMLElement>;

						h4Elements.forEach((h4Element) => {
							const nextUl = h4Element.nextElementSibling as HTMLElement;
							if (nextUl && nextUl.tagName === "UL") {
								const listItems = nextUl.querySelectorAll("li") as NodeListOf<HTMLElement>;
								let hasVisibleItems = false;

								// Filter li elements in this specific ul
								listItems.forEach((li) => {
									if (!regex) {
										// When filter is empty, reset li visibility but don't set hasVisibleItems
										li.style.display = "";
									} else {
										const text = li.textContent?.toLowerCase() || "";
										if (regex.test(text)) {
											li.style.display = "";
											hasVisibleItems = true;
										} else {
											li.style.display = "none";
										}
									}
								});

								// Show/hide h4 and ul based on whether any li items are visible
								if (!regex) {
									// When filter is empty, hide all ULs
									h4Element.style.display = "";
									h4Element.style.fontWeight = "normal";
									nextUl.style.display = "none";
									nextUl.classList.add("hidden");
								} else if (hasVisibleItems) {
									h4Element.style.display = "";
									nextUl.style.display = "";
									nextUl.classList.remove("hidden");
								} else {
									h4Element.style.display = "none";
									nextUl.style.display = "none";
								}
							}
						});
					});
				}, 150);
			});

			// Autocomplete item click handler
			autocompleteDiv.addEventListener("click", (e) => {
				const target = e.target as HTMLElement;
				if (target.classList.contains("autocomplete-item")) {
					skipAutocomplete = true;
					const dataStr = target.dataset.str || "";
					regfilter.value = dataStr;
					autocompleteDiv.classList.add("hidden");
					regfilter.dispatchEvent(new Event("input"));
				}
			});

			// Keyboard navigation
			regfilter.addEventListener("keydown", (e) => {
				// Reset skip flag when user starts typing or clearing
				if (e.key.length === 1 || e.key === "Backspace" || e.key === "Delete") {
					skipAutocomplete = false;
				}

				const items = autocompleteDiv.querySelectorAll(
					".autocomplete-item",
				) as NodeListOf<HTMLElement>;
				if (items.length === 0) return;

				if (e.key === "ArrowDown") {
					e.preventDefault();
					selectedIndex = Math.min(selectedIndex + 1, items.length - 1);
					updateSelection(items, selectedIndex);
				} else if (e.key === "ArrowUp") {
					e.preventDefault();
					selectedIndex = Math.max(selectedIndex - 1, -1);
					updateSelection(items, selectedIndex);
				} else if (e.key === "Enter" && selectedIndex >= 0) {
					e.preventDefault();
					skipAutocomplete = true;
					const dataStr = items[selectedIndex].dataset.str || "";
					regfilter.value = dataStr;
					autocompleteDiv.classList.add("hidden");
					regfilter.dispatchEvent(new Event("input"));
				} else if (e.key === "Escape") {
					autocompleteDiv.classList.add("hidden");
					selectedIndex = -1;
				}
			});

			function updateSelection(items: NodeListOf<HTMLElement>, index: number) {
				items.forEach((item, idx) => {
					if (idx === index) {
						item.classList.add("bg-gray-200");
					} else {
						item.classList.remove("bg-gray-200");
					}
				});
			}

			const wordlistResult = document.querySelectorAll(
				"#abacus-wordslist div ul li",
			) as NodeListOf<HTMLElement>;

			Array.from(wordlistResult).forEach((item) => {
				item.addEventListener("click", (e) => {
					// Reset all other LI elements to normal weight
					wordlistResult.forEach((li) => {
						li.style.fontWeight = "normal";
					});

					// Make clicked item bold
					item.style.fontWeight = "bold";

					const noskeInput = document.getElementById("noske-input-input") as HTMLInputElement;

					const noskeSelect = document.getElementById("noske-input-select") as HTMLSelectElement;
					noskeSelect.value = "cql";

					// @ts-ignore
					//noskeInput.value = e.target!.textContent;
					noskeInput.value = `[${id}="${e.target!.dataset.str}"]`;
					//noskeInput.dispatchEvent(new Event("", { bubbles: true }));
					const searchButton = document.getElementById("noske-search-button") as HTMLButtonElement;
					searchButton.click();
				});
			});

			const rgAbc = document.querySelectorAll("#rg-abc h4") as NodeListOf<HTMLElement>;

			Array.from(rgAbc).forEach((item) => {
				item.addEventListener("click", (e) => {
					const target = e.target as HTMLElement;
					// Find the h4 element (whether clicked directly or on a child element)
					const h4Element = target.closest("h4") as HTMLElement;

					if (h4Element) {
						const ul = h4Element.nextElementSibling as HTMLElement;
						if (ul.classList.contains("hidden")) {
							ul.classList.remove("hidden");
							ul.style.display = "";
							h4Element.style.fontWeight = "bold";
						} else {
							ul.classList.add("hidden");
							ul.style.display = "none";
							h4Element.style.fontWeight = "normal";
						}
					}
				});
			});
		});
	});

	const pushOrCreate = (obj: any, key: string, item: { str: string; frq: string }) => {
		try {
			obj[key].push(createListItem(item));
		} catch (error) {
			obj[key] = [];

			obj[key].push(createListItem(item));
		}
	};

	const createListItem = (item: { str: string; frq: string }) => {
		return `<li class="cursor-pointer text-red-600" data-str="${item.str}">${item.str} (${item.frq})</li>`;
	};

	// Toggle examplelist visibility when clicking on example div
	const exampleDiv = document.getElementById("example") as HTMLElement;
	const exampleList = document.getElementById("examplelist") as HTMLElement;

	exampleDiv?.addEventListener("click", () => {
		exampleList?.classList.toggle("hidden");

		// Toggle arrow rotation
		const arrows = exampleDiv.querySelectorAll(".arrow") as NodeListOf<HTMLElement>;
		arrows.forEach((arrow) => {
			if (arrow.classList.contains("rotate-180")) {
				arrow.classList.remove("rotate-180");
				//arrow.classList.add("-rotate-90");
			} else {
				//arrow.classList.remove("-rotate-90");
				arrow.classList.add("rotate-180");
			}
		});
	});
</script>
